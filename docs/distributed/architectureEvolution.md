---
title: 服务架构演进史
date: '2022-08-23 22:01:03'
description: 借讨论历史之名，梳理微服务发展历程中出现的大量技术名词、概念。
abbrlink: b2cbea7
---



## 原始分布式时代


* **分布式架构的目标是使用多个独立的分布式服务，来共同构建一个更大型的系统。**

* **分布式架构出现的最初目的：解决单台机器的性能瓶颈问题。**


分布式会面临的一系列问题，比如说：远程的服务在哪里（服务发现）、有多少个（负载均衡）、如何和远程服务通信（远程服务调用）、网络出现分区、超时或者服务出错了怎么办（熔断、隔离、降级）、方法的参数和返回结果如何表示（序列化协议）、如何传输（传输协议）、服务权限如何管理（认证、授权）、如何保证通信安全（网络安全层）、如何令调用不同机器的服务能返回相同的结果（分布式数据一致性）等一系列问题。

:::note

 分布式系统的设想和尝试出现于半个世纪前，当时的计算机硬件的运算能力还相当薄弱，为了突破硬件算力的限制，各个高校、研究机构、软硬件厂商开始了对分布式架构最原始的探索。<br/>
但因当时的各种限制（虽然当时上述分布式问题都被一一解决并提出了 DCE 标准，但使用分布式所付出的代价远远大于收益），不得不以失败告终（当时正是摩尔定律发挥作用的黄金时期，微型计算机的性能以每两年就增长一倍的惊人速度在提升，硬件算力不再束缚软件规模，单体系统很快就成为了主流）。所以在当时的计算机科学面前，有两条通往更大规模软件系统的道路:<br/>

* 尽快提升单机的处理能力，以避免分布式的种种问题；
 * 找到更完美的解决方案，来应对分布式系统存在的问题;

:::

## 单机系统时代：应用最广泛

单体架构是出现时间最早、应用范围最广、使用人数最多、统治时间最长的一种架构风格。但“单体”这个名称，却是微服务开始流行之后，才“事后追认”所形成的概念。在这之前，并不会把“单体”看成是一种架构。

对于小型单体系统，也就是用单台机器就足以支撑其良好运行的系统来说，这样的单体不仅易于开发、易于测试、易于部署，而且因为各个功能、模块、方法的调用过程，都是在进程内调用的，不会发生进程间通讯,所以程序的执行效率也要对分布式高。所以，讨论单体架构的缺陷，是在软件的性能超过了单机，软件的开发人员规模明显超过了“2 Pizza Teams”范畴的时候才有意义。


:::tip 进程间通讯

Inter——Process Communication,IPC.RPC属于IPC的一种特例。

:::

单体系统在获得了进程间调用的简单、高效这些好处的同时，但如何任何一部分代码出现了缺陷，会过度的消耗进程空间内的公共资源，所造成的影响就是全局性的。同样因为所有代码都共享者同一个进程空间，如果代码无法隔离，就无法做到单独停止、更新、升级某一部分代码。


**单体架构损失了各个功能模块的自治、隔离能力，还带来了技术异构等困难**

:::tip 技术异构

允许系统中的每个模块，自由选择不一样的编程语言，不一样的编程框架去实现。

:::

### 可拆分的单体系统

* 纵向拆分：分层架构（Layered Architecture）已经是现在几乎所有信息系统建设中，都普遍认可、普遍采用的软件设计方法了。无论是微服务还是单体，都会对代码进行纵向拆分，收到的外部请求会在各层之间，以不同形式的数据结构进行流转传递，在触及到最末端的数据库后依次返回响应。

* 横向拆分：单体架构也可以按照技术、功能、职责等角度，把软件拆分为各种模块，以便重用和团队管理。单体系统并不意味着只能有一个整体的程序封装形式，如果有需要，它完全可以由多个 jar 、war包组成。

* 水平扩展：单体架构也可以在负载均衡器之后，同时部署若干个单体系统的副本，以达到分摊流量压力的效果。

**单体系统的真正缺陷实际上并不在于要如何拆分，而是拆分后，它会存在隔离与自治能力上的缺陷。**

**单体系统最大的问题，是不具备涅槃重生的特性**，这也是微服务逐渐代替单体系统的根本原因。

### 单体的适用场景

**对于小型系统，单体架构就是最好的架构**

单体这种架构风格，潜在的观念是希望系统的每一个部件，甚至每一处代码都尽量可靠，不出、少出错误，致力于构建可靠系统。

这种观念在小规模软件上能良好运作，但当系统越来愈大的时候，交付一个可靠的单体系统就会越来越有挑战性。所以构建可靠系统的观念，开始从“追求尽量不出错”，转变为了“出错是必然，只要出了问题能够兜底，能重回正轨就好”

这也是微服务架构能够逐步开始替代运作了几十年的单体架构的根本驱动力。

在公司的初始阶段，为了业务的快速上线，必须得采用单体架构，随着业务得增长，架构才得以演进。

:::tip

 * 微服务其实就是一群小单体，是整个系统的一部分。
 * 单体系统在“小卖部”阶段很合适，随着“小卖部”越来越大，会被拆分成微服务，而随着微服务的不断迭代，肯定会有某个微服务变成另一个大型单体，还是需要继续拆分。

:::

## SOA时代：成功理论和失败实践

SOA架构是第一次被广泛使用的、通过分布式服务来构建信息系统的工程实践。但它最终还是没能成为一种普适的软件架构。

当软件架构发展到SOA时代的时候，其中的很多概念、思想已经能在微服务中找到对应的身影了。比如，服务之间的松散耦合、注册、发现、治理、隔离、编排等等。也大多是分布式服务刚被提出的时候，就已经预见到的困难。

但SOA架构过于严谨精密的流程与理论，导致了软件开发的全过程，都需要有懂得复杂概念的专业人员才能够驾驭。所以很难作为一种具有广泛普适性的软件架构分格来推广。

> SOA最终没有获得成功的致命伤，其实跟当年的EJB（Enterprise JavaBean，企业级JavaBean）的失败如出一辙。
> 所以"任何事物一旦脱离了人民群众，最终都会淹没在群众的海洋之中"，信息技术也不例外。
> 可见,把一门技术做得既能够解决问题，又足够简单，才是持续发展的重点。

## 微服务时代

微服务这个词在2005年就已经提出和使用了，是SOA发展的同时被催生出来的产物。就像EJB在推广的过程中，催生出了Spring和Hibernate框架那样。
但微服务真正崛起是在2014年，Martin Fowler 和 James Lewis 合写的文章中“[Microservices: a definition of this new architectural term](https://martinfowler.com/articles/microservices.html)”提出了真正丰富的、广为人知的和可操作的微服务指南。

在此文中，首先给出了现代微服务的概念：

> 微服务是一种通过多个小型服务的组合，来构建单个应用的架构风格，这些服务会围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言、不同的数据存储技术、运行在不同的进程之中。服务会采用轻量级的通讯机制和自动化的部署机制，来实现通讯和部署。

:::tip 微服务的目的

微服务的目的是有效的拆分应用，实现物理层面的隔离。

微服务的核心价值就是拆分之后的系统能够让局部的单个服务有可能实现敏捷地拆卸、部署、开发、升级。局部的持续迭代，这也是系统整体具备生命力的必要条件。

:::

### 微服务九大特征

此外，作者还列举出了微服务的九个核心的业务和技术特征。这九个特征，是一个合理的微服务系统应该展现出来的内、外在表现。如下：

####  围绕业务能力构建

**有怎样的结构、规模和能力的团队，就会产生出对应结构、规模、能力的产品。**这是必然的演化结果。

如果本该归属同一个产品内的功能，被划分在了不同的团队当中，那就必然会产生大量的跨团队沟通协作，而跨团队边界，无论是在管理、沟通，还是工作安排上，都会产生更高的成本。高效的团队，自然会针对这个情况进行改进。

> 不要将UI丢给UI团队、数据库丢给DBA团队、应用逻辑丢给业务开发团队。

####  分散治理

微服务对应的开发团队，有着直接对服务运行质量负责的责任，也应该有着不受外界干扰，掌控服务各个方面的权利，可以选择与其他服务异构的技术来实现自己的服务。

这一点在真正实践的时候，通常都会统一主流语言，甚至会统一技术栈。微服务不提倡也不反对这种”统一”。

微服务更加强调的是，**在确实有必要进行技术异构的时候，一个开发团队应该能有选择“不统一”的权利**。比如说，我们不应该强迫用 Node.js去开发报表页面；要做人工智能计算的时候，也可以选择用Python，等等。

####  通过服务来实现独立自治的组件

这里，作者强调要通过“服务”而不是“类库”来构建组件，这是因为类库是在编译器静态链接到程序中的，会通过本地调用来提供功能，而服务是进程外组件，它是通过远程调用提供功能的。尽管远程调用有更高昂的成本，但这是为组件带来隔离与自治能力的必要代价。

:::tip 

微服务架构也会使用到类库，但构成软件系统组件的主要方式是将其拆分为一个个服务。

:::
 
####  产品化思维

产品化思维的意思就是，我们要**避免把软件研发看作是要去完成的某种功能，而要把它当作是一种持续改进、提升的过程。**比如，我们不应该把运维看作就是运维团队的事，把开发看作就是开发团队的事。



开发团队应该为软件产品的整个生命周期负责。开发者不仅应该知道软件是如何开发的，还应该知道它会如何运作、用户如何反馈，乃至售后支持工作是怎样进行的。这里服务的用户，不一定是最终用户，也可以是消费这个服务的另一个服务。

单体架构模式下，程序的规模决定了无法让全部的开发人员，都关注一个完整的产品，但是在微服务下，我们可以让团队中的每一位成员，都具有产品化思维。

因为在 “2 Pizza Teams” 的团队规模下，每一个人都了解全过程是完全能实现的。

####  数据去中心化

微服务这种架构模式也明确地提倡，数据应该按领域来分散管理、更新、维护和存储。

在单体服务中，通常一个系统的各个功能模块都会使用同一个数据库，虽然这种中心化的存储确实天生就更容易避免一致性的问题，但是，同一个数据实体在不同服务的视角里，它的抽象形态也往往是不同的。如果是作为中心化的存储，那么这里所有的邻域，都必须修改和映射到同一个实体中，就会导致不同的服务之间，可能会互相产生影响，从而丧失了各自的独立性。

####  轻量级通讯机制

微服务反对ESB、BPM和SOAP等复杂的通讯机制，ESB可以处理消息的编码加工、业务规则转换等；

这些构筑在通讯管道上的功能，并不是所有的服务都是需要的。

**如果服务需要上面的某一种功能或能力，那就应该在服务自己的 Endpoint（端点）上解决，而不是在通讯管道上一揽子处理**

微服务提倡的是类似于经典Unix过滤器那样，简单直接的通讯方式。比如，RESTful分格的通讯，在微服务中就比较合适。

####  容错性设计

容错性设计，是指软件架构不再虚拟地追求服务永远稳定，而是接受服务总会出错的事实。

这个技术特征要求，在微服务的设计中，有自动的机制能够对其依赖的服务进行快速故障检测，在持续出错的时候进行隔离，在服务恢复的时候重新联通。

所以**“断路器“这类设施，对微服务来说，并不是可选的外围组件，而是必不可少的组件。**如果没有容错性的设计，系统很容易就会因为一两个服务的崩溃带来的雪崩效应而淹没。

:::tip 微服务观念

可靠性的系统完全可以由会出错的服务来组成。<br/>
有了容错的考虑，才会有可用性的保证。

:::


#### 演进式设计

容错性设计承认服务会出错，而演进式设计则是**承认服务会被淘汰报废**。（可以继续拆分或合并）

一个良好设计的服务，应该是能够报废的，而不是期望得到长久的发展。如果一个系统中出现不可更改，无可替代的服务，这并不能说明这个服务有多么重要，反而是系统设计上脆弱的表现。微服务带来的独立、自治，也是在反对这种脆弱性。

:::tip 

完善的微服务体系要求服务有涅槃重生的过程，有强大的容错能力。

因为每个微服务粒度都足够小，出现代码恶化现象能够方便修正、重构，即使重新编码，更换实现方式。

系统提前设计半步，团队成员还能更得上，提前设计2-3步，复杂性变高，开发人员不能理解就会越做越歪。

:::

####  基础设施自动化

基础设施自动化，如CI/CD，大大降低了构建、发布、运维工作的复杂性。

由于微服务架构下，服务数量比起单体架构来说，要有数量级的增长，所以微服务系统会更加依赖于基础设施的自动化。

:::tip 微服务系统应具有以自治为目标的自动化与监控度量能力

Martin Fowler 在《Microservice Prerequisites》中提出的微服务系统的三个技术前提：分别是
* 环境部署：有能力在短时间内迅速的启动好一台新的服务器。
* 基础监控：监控体系有能力迅速捕捉到系统中出现的技术问题（如异常、服务可用性变化）和业务问题（如使用量下降）。
* 快速部署：有能力通过全自动化的部署，将服务的变更迅速部署到测试或生产环境中。

:::

:::note 微服务自动化的最终目的是构筑一个可持续的生态系统。

如果将微服务比作水族馆里养的鱼，为了维持鱼的生存，管理员需要不断向水族馆内添加各种自动化设施：人工照明、氧化剂、水过滤器、加热器，等等。这些设施最终仍然需要人花费精力去照料维护，本身就耗费了大量成本。如果我们换一种思路，通过种植海洋植物以提供氧气、通过藻类过滤水质、通过放养螺类来清理鱼缸等等。这样的水族馆就不再是依靠人工维护才能存在的水族馆了，它变成了一个小型的湖泊或海洋，理想状态下，这里的鱼类可以不需要人的干预就能长期存活

:::



### 微服务总结

* **微服务架构下，我们需要解决什么问题，就引入什么工具；团队熟悉什么技术，就使用什么框架。**
* SOA架构对分布式问题的解决提供了一系列工具，微服务则追求的是更加自由的架构风格，提倡以”实践标准“代替”规范标准“。
* 服务的注册与发现、跟踪治理、负载均衡、故障隔离、认证授权、伸缩扩展、传输通讯、事务处理等问题，在微服务中，都不再会有统一的解决方案。
* 微服务是通过领域建模理论将一个大型应用拆分成了更细粒度且边界清晰的服务模块。而且，每个微服务都能被独立测试、独立部署，并借助 CICD（持续集成环境）完成快速上线。
* 每个微服务拥有独立的代码库和数据库 Schema，通常由一个小规模的微服务技术团队全权负责，这个团队汇聚了产品、技术、架构等人员，采用 Scrum 之类的敏捷开发流程做快速迭代。基于此，微服务具备了“独立演进”的能力。
* 优势
  * 快速迭代+ 快速回滚
  * 资源利用大大提高
  * 大幅降低协作成本
  * 高可用、高扩展


## 云原生时代

在微服务架构中，会面临一些必须解决的问题，比如服务注册发现、跟踪治理、负载均衡、传输通讯等。

只要是分布式系统，就没办法完全避免这些问题。

所以，在微服务时代，之所以不得不在应用服务层面，而不是基础设施层面去解决这些分布式问题，**完全是因为由硬件构成的基础设施，跟不上由软件构成的应用服务的灵活性。**

一旦硬件能够跟的上软件的灵活性，那么这些与业务无关的技术问题，便很可能从软件的层面剥离出来，在硬件的基础设施之内就被悄悄解决掉，让软件可以只专注于业务，真正围绕业务能力构建”团队与产品“。那么原来只能从软件层面解决的分布式架构问题，于是有了另一种解法：应用代码与基础设施软硬一体，合力应对。

云原生追求的目标，跟此前微服务时代中追求的目标相比，并没有什么本质的改变，他们都是通过一系列小型服务去构建大型系统。

### 云原生解决方案

 2017 年，Kubernetes最终从众多的容器管理系统中脱颖而出。它带来的容器间网络、服务发现、负载均衡、配置等虚拟化基础设施，也成为被业界广泛认可、普遍采用的通过虚拟化的基础设施，去解决分布式架构问题的方案。

![SpringCloud和Kubernetes解决方案对比](https://img.wkq.pub/hexo/bb53ddc9eec69bd1cd175aa50d64d7d6.jpg)

为了解决断路器、以及服务的监控、认证、授权、安全、负载均衡等功能的精细化管理，微服务基础设施引入了”服务网格（Service Mesh）“的"边车代理模式（Sidecar Porxy）"

> 微服务基础设施会由系统自动地在服务的资源容器（指 Kubernets 的 Prod）中注入一个通讯代理服务器（相当于边车的挎斗），用类似网络安全中的中间人攻击的方式进行流量劫持，在应用毫无感知的情况下，悄悄接管掉应用的所有对外通讯。

这个代理除了会实现正常的服务调用以外，同时还接受来自控制器的指令（称为控制平面通讯），根据控制平面中的配置，分析数据平面通讯的内容，以实现熔断、认证、度量、监控、负载均衡等各种附加功能。

![istio](https://img.wkq.pub/hexo/91398fb51025b24ff89305aec1c99678.jpg)

### 总结

* k8s实现了基础设施的软件化，让基础设施能跟上软件变化
* K8S不能处理提供服务熔断、降级，而且基础设施是针对整个容器来做整体管理的，所以粒度就相对粗犷，所以引入了 服务网格进行解决这些问题。
* SpringCloud 解决方案是在应用层面解决问题，Kubernets 是在基础设施层面解决问题。
* K8S真正做到了业务与技术完全分离，远程与本地完全透明，这也许就是分布式架构最好的时代了。

## 无服务时代

分布式架构出现的最初目的，是要解决单台机器的性能成为整个软件系统的瓶颈的问题。后来随着随着技术的演进，容错能力、技术异构、职责划分等其它因素，也都成了分布式架构要考虑的问题。但不可否认，获得更好的性能，仍然在架构设计中占有非常大的比重。

因为分布式架构会引入一些新问题，因此对于软件开发，不去做分布式无疑是最简单的。如果单台服务器的性能可以是无限的。那架构演进结果，肯定会跟今天不一样。不管是分布式还是容器化，还是微服务。



绝对意义上的无限性能肯定是不存在的，但相对意义上的无限性能其实已经实现了。对基于云计算的软件系统来说，无论用户有多少、逻辑如何复杂，阿里云等云服务提供商都能在算力上满足系统对性能的需求。**它最大的卖点就是简单**，只涉及了后端设施（Backed）和函数（Function）两块内容。

* 后端设施是指数据库、消息队列、日志、存储等这一类用于支撑业务逻辑，但本身无业务含义的技术组件。这些后端设施都运行在云中，也就是无服务中的“**后端即服务**”（Backend as a Service，Baas）
* 函数指的就是业务逻辑代码。这里函数的概念与粒度，都已经和程序编码角度的函数非常接近了，区别就在于，无服务中的函数运行在云端，不必考虑算力问题和容量规划，这也就是无服务中的“**函数即服务**”（Funcation as a Service，Faas）

**无服务的愿景是让开发者只需要纯粹地关注业务**：一是，不用考虑技术组件，因为后端的技术组件都是现成的，可以直接取用。二是，不需要考虑如何部署，因为部署过程是完全托管到云端的，由云端自动完成；三是；不需要考虑算力，因为由整个数据中心的支撑，算力可以认为是无限的；四是，也不需要运维，维护系统持续地平稳运行是云服务商的责任，而不再是开发者的责任。

> 就像从汇编语言发展到高级语言，开发者不用再去关注寄存器、信号、中断等与机器底层相关的细节

根据腾讯公开的资料，企业微信、QQ小程序、腾讯新闻等产品，就是使用自己的无服务框架构成的微服务系统。

无论是通过物理机、虚拟机、容器、或者是无服务云函数，都会是微服务实现方案的一个候选项。

### 总结

* 无服务架构（Serverless）跟微服务架构没有关系，它们并不是同一个层次的架构。
* 无服务的云函数可以作为微服务的一种实现方式。
* Serverless包括两块内容 Backed 和 Funcation