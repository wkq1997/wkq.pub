---
title: Nacos 体系结构
---

## 什么是服务治理

### 服务治理解决的问题

假设系统包含两个服务（服务 A 和 服务 B），每一个微服务有 10 个虚拟节点，两个服务组成了一个 20 台虚拟机的微服务集群。如果此时微服务 A 想要调用 微服务 B 。

一种通用的做法是：在服务 A 的配置文件中添加一个指向服务 B 的地址，但这个地址并不直接指向任何一台服务 B 集群中的节点，而是指向一个 VIP（虚拟 IP 地址）或者是一个网关。这个 VIP 或网关背后维护了 B 集群的服务节点列表，VIP 层通过负载均衡策略再将请求转到后面配置的某一台服务器。如下图：

![fcd15ed204d43fe615cb50acbe58010d](https://img.wkq.pub/hexo/fcd15ed204d43fe615cb50acbe58010d.webp)

从上面的图可以看出，服务 A 与服务 B 之间互相不直接通信，服务调用完全依靠 VIP 作为中间人来完成。我们如果想要为服务集群扩容或缩容，必须将服务器配置到对应的 VIP 地址上。

那么在微服务架构中，怎么才能实现一种简单可靠的远程服务调用，不让 VIP 中间商赚差价呢，这就说到服务治理理了。

### 服务治理

如果我们要解决中间商赚差价的问题，那么最找的办法就是让双方直连。因此，服务治理要解决的首要问题就是 **服务注册**与**服务发现**，通过这两项技术，我们就能让微服务之间发起面对面的直接调用。

那么服务 A 怎么知道 服务B 中每台机器的地址呢？为了让服务 A 拿到服务 B 的节点清单，我们需要搭建一个**中心化的服务注册中心**，服务 B 只要将自己的信息添加到注册中心里，服务 A 就能从注册中心获取到服务 B 的所有节点列表。如下图：

![81bd88faec1dd053104c3be5b6792de2](https://img.wkq.pub/hexo/81bd88faec1dd053104c3be5b6792de2.webp)

从上图中的步骤中我们可以看出，首先，服务 B 集群向注册中心发起了注册，将自己的地址信息上报到注册中心，这个过程就是**服务注册**。接下来，每隔一段时间，服务 A 就会从服务中心获取服务 B 集群的服务列表，或者有服务注册中心将服务列表的变动推送给服务 A ，这个过程叫做服务发现；最后，服务 A 根据本地负载均衡策略，从服务列表中选取某一个服务 B 的节点，发去服务调用。

在这个过程中，**注册中心的角色是一个中心化的信息管理者**，所有的微服务节点在启动后都会将自己的地址信息添加到注册中心。在服务注册的过程中，有两个关键信息是最为重要的，如下：

1. **服务名称**：服务名称通常默认是 spring.application.name 属性，在服务注册过程中我们必须将应用服务名上报到注册中心，这样其它服务才能根据服务名称找到对应的服务节点列表；
2. **地址信息**：包括服务节点的 IP 地址和端口

通过上面这两个信息，调用方就能精确定位到目标微服务。除此之外，服务注册请求中还包含一些额外的注册信息。

通过服务注册和服务发现，我们已经能够实现端到端的服务调用链路，但这个方案并不完整，它还缺少了**异常容错**的机制。

如果服务 B 集群因为未知的网络故障导致无法响应服务，这时候服务 A 向服务 B 发起了服务调用，就会发生超时或者服务无响应的异常情况。

业界通用的解决方案是 “heathcheck” 或者 “heartbeat”，又叫“服务探活” 或 “心跳检测”。注册中心可以通过这种机制来标记异常服务，这样一来，Client 端在发送服务请求的时候就能避开异常节点。服务完成的生命周期如下图：

![f1ca43ff75242242a8b97b3df63a0ae7](https://img.wkq.pub/hexo/f1ca43ff75242242a8b97b3df63a0ae7.webp)

**服务剔除**的大前提是。所有的服务都要在注册中心进行注册，而且每个节点都需要每隔一段时间向注册中心同步自己当前的状态，这个过程被称为 heartbeat（心跳）。

如果节点持续发送心跳信息，则一切正常，服务可以被发现；如果注册中心在一段时间内没有收到 Client 的心跳包，注册中心就会将这个节点标记为下线状态，进而将该服务从服务列表中剔除。

上面说的“服务剔除”是由注册中心主导的“被动下线”场景。除此之外还有一类服务“主动下线”的场景，也就是当服务节点关闭或者重启的时候，通过发送一条“服务下线”指令给到注册中心，将当前节点标记为下线状态。

## Nacos 体系架构

Nacos 有三个核心知识点：领域模型、数据模型和基本架构。

### 领域模型

Nacos 领域模型描述了服务与实例之间的边界和层级关系。Nacos 的服务领域模型是以“服务”为维度构建起来的，这个服务并不是指集群中的单个服务器，而是指微服务的服务名。

“服务”是 Nacos 中位于最上层的概念，在服务之下，还有集群和实例的概念。如下图：

![21d3938ce122a48652397c329b361948](https://img.wkq.pub/hexo/21d3938ce122a48652397c329b361948.webp)

Nacos 的服务领域模型从上到下分为了 服务、集群和实例三层。

#### 1. 服务

在服务这个层级上我们可以配置元数据和服务保护阈值等信息。服务阈值是一个 0~1 之间的数字，当服务的健康实例数与总实例的比例小于这个阈值的时候，说明能提供服务的机器已经没多少了。这时候 Nacos 会开启服务保护模式，不再主动剔除服务实例，同时还会将不健康的实例也返回给消费者。尽管这样做可能会造成请求失败，但间接保证了最低限度的服务可用性。

#### 2. 集群

一个服务由很多服务实例组成，在每个服务实例启动的时候，我们可以设置它所属的集群，在集群这个层级上，我们也可以配置元数据。除此之外，我们还可以为持久化节点设置健康检查模式。

所谓的持久化节点，是一种会保存到 Nacos 服务端的实例，即便该实例的客户端进程没有在运行，实例也不会被服务端删除，只不过 Nacos 会将这个持久化节点状态标记为不健康，Nacos  可以采用一种“主动探活“的方式来对持久化节点做健康检查。

除了持久化节点以外，大部分服务节点在 Nacos 中以 ”临时节点“的方式存在，它是默认的服务注册方式，从名字可以我们就可以看出，这种节点不会被持久化保存在 Nacos 服务器，临时节点通过主动发送 heartbeat 请求向服务器上报自己的状态。

#### 3. 实例

这里所说的实例就是指服务节点，我们可以在 Nacos 控制台查看每个实例的 IP 地址和端口、编辑实例的元数据信息、修改它的上线/下线状态或者配置路由权重等等。

你会发现，在这三个层级上都有”元数据“这一数据结构，可以把它理解为一组包含了服务描述信息（如服务版本）和自定义标签的数据集合。Client 端通过服务发现技术可以获取到每个服务实例的元数据。可以将自定义的属性加入到元数据并在 Client 端实现某些定制化的业务场景。



服务调用的发起方是如何定位到领域模型中的服务实例的，这就要说起 Nacos 的数据模型了

### 数据模型

Nacos 的数据模型有三个层次结构，分别是 Namespace、Group 和 Service / DataId，如下图：

![e89a90d5cdb2d4929a8e44cf5c747fee](https://img.wkq.pub/hexo/e89a90d5cdb2d4929a8e44cf5c747fee.webp)

从上图中可以看出，Namespace、Group 和 Service /DataId 是一个依次包含的结构

* **Namespace**： 即命名空间，它是最顶层的数据结构，我们可以用它来区分开发环境、生产环境等不同环境。默认情况下，所有的服务都部署到一个叫做 public 的公共命名空间。
* **Group**： 在命名空间之下有一个分组结构，默认情况下所有微服务都属于 ”DEFAULT_GROUP“ 这个分组，不同分组间的微服务是互相隔离的。
* **Service / DataId**：在 Group 分组之下，就是具体的微服务了，比如订单服务、商品服务等等。

通过 **Namespace + Group + Service / DataId** , 就可以精准定位到一个具体的微服务。比如，我想调用生产环境下  A 分组的订单服务，那么对应的服务寻址 key 就是类似 Production.A.orderService的组合。

### 基本架构

Nacos 的核心功能有两个，一个是 **Naming Service**，也就是用来做服务发现的模块；另一个是 **Config Service**，用来提供配置项管理、动态更新配置和元数据的功能。如下图：

![d3a2227dcdab8b7ddc786c9653c6bc59](https://img.wkq.pub/hexo/d3a2227dcdab8b7ddc786c9653c6bc59.webp)

从上面的图可以看出，Provider APP 和 Consumer APP 通过 Open API 和 Nacos 服务器的核心模块进行通信。这里的 Open API 是一组对外暴露的 RESTful 风格的 HTTP 接口。

在Nacos 核心模块里，Naming Service 提供了将对象和实体 ”名字“映射到元数据的功能，这是服务发现的基本功能之一。例如，我想要调用 OrderService，我手里有这个服务的 Namespace 和 Group 信息，那么我就可以通过 Naming Service 定位到这个服务对应的实例列表。同理，如果我有一个 DNS 名称，同样可以借助 Naming Service 获取 DNS 背后配置的 IP 列表。以上两个场景就分别对应了服务发现和 DNS 功能，这两个场景都是 Naming Service 的核心场景。

Nacos 还有一个相当重要的模块：**Nacos Core** 模块。它可以提供一系列的平台基础功能，是支撑 Nacos 上层业务场景的基石。

| Nacos Core 模块名 | 模块描述                                                     |
| ----------------- | ------------------------------------------------------------ |
| 启动模块          | 按照 Standalone单机、Cluster 集群、DNS等多种模式启动底层的程序和 UI 界面 |
| 寻址模块          | 实现根据域名、naming 服务、IP 端口、广播等多种不同途径的寻址。 |
| 存储模块          | 负责 Nacos 服务信息的存储，实现了基于文件、数据库等多种存储介质的持久化方案，同时解决数据分片的问题。 |
| 插件模块          | 实现可插拔的插件扩展点。Nacos 通过插件机制提供了用户接入管理、角色和权限管理、审计功能、SMS通知接入、监控统计等众多的功能性插件。 |
| 缓存机制          | 实现本地、服务端缓存，以及容灾支持的功能                     |
| 事件通知          | 负责异步化的事件通知                                         |
| 日志模块          | 管理日志的格式、日志级别和分类，保证日志的可移植性           |
| 容量管理模块      | 管理每个 Namespace 和 Group 维度下的容量，防止存储空间被写满而导致的服务不可用 |

除了 Nacos Core 提供的这些功能以外，Nacos 还有一个”一致性协议”，用来确保 Nacos 集群中各个节点之间的数据一致性。Nacos 内支持两种一致性协议，一种是侧重一致性的 Raft 协议，基于集群中选举出来的 Leader 节点进行数据写入；另一种是针对临时节点的 Distro 协议，它是一个侧重可用性（或最终一致性）的分布式一致性协议。

## Nacos 集群环境搭建

我们在做系统架构设计的时候，首要目标就是保障系统的高可用性。不管你的系统多么精妙，用的技术多么先进，如果系统的可用性无法的到保障，那么你所做的都是白忙活。

保障系统的高可用性有两个方向。

* **避免单点故障**：在做系统架构的时候，应该假设任何服务器都有可能挂掉。如果某项任务依赖单一服务资源，那么这就会成为一个“单点”，一旦这个服务资源挂掉就表示整个功能变为不可用。所以要尽可能消灭一切单点。
* **故障机器状态恢复**：尽快将故障机器返回到故障前的状态。对于像 Nacos 这类中心化注册中心来说，因故障而下线的机器在重新上线后，应该有能力从某个地方获取故障发生前的服务注册列表。

那 Nacos 是如何解决上面的两个问题，来保证自己的高可用的呢？很简单，就是构建服务集群。集群环境不仅可以有效规避单点故障引发的问题，同时对于故障恢复的场景来说，重新上线的机器也可以从集群中的其它节点同步数据信息，恢复到故障前的状态。

下面，开始搭建 Nacos Server 的集群环境。

### 下载 Nacos Server

Nacos Server 的安装包可以从 Alibaba 官方 Github 中的 [Release 页面]([Releases · alibaba/nacos (github.com)](https://github.com/alibaba/nacos/releases))下载，这里选择的版本是 2.1.1.

![image-20220918221847582](https://img.wkq.pub/hexo/image-20220918221847582.png)

可以在 nacos-server-2.1.1.tar.gz 和 nacos-server.2.1.1.zip 这两个压缩包中任选一个下载。

下载完成后，你可以在本地将 Nacos Server 压缩包解压，并将解压后的目录名改为 “cluster1”，再复制一份同样的文件到 ”cluster2“，以此来模拟一个由两台 Nacos Server 组成的集群。

![image-20220918222443211](https://img.wkq.pub/hexo/image-20220918222443211.png)

到这里，就完成了 Nacos Server 的下载安装，接下里修改 Nacos Server 的启动项参数。

### 修改启动项参数

Nacos Server 的启动项位于 conf  目录下的 application.properties 文件里，只需要修改这里的服务启动端口和数据库连接。

因为需要在一台机器上同时启动两台 Nacos Server 来模拟一个集群环境，所以这两台 Nacos Service 需要使用不同的端口。

Nacos Server 的启动端口由 server.port 属性指定，默认端口是 8848。只需要把 cluster2 中的端口号修改掉就可以了，这里我把它改为 8849。



## 集成 Nacos

下游服务需要先将自己作为”服务提供者“注册到Nacos ，这个流程叫做”服务注册“；而上游服务作为”服务消费者“，需要到 Nacos 中获取可供调用的下游服务的列表，这个过程就是”服务发现“。

在集成 Nacos 之前，需要先把 Nacos 的依赖项引入到项目中。

### 添加 Nacos 依赖

Nacos 是Spring Cloud Alibaba 项目的一款组件，在引入 Nacos 的依赖项之前，我们需要在项目的顶层 pom 中定义所要使用的 SpringCloud 和 Spring Cloud Alibaba 的版本。

Spring  Boot、Spring Cloud 和 Spring Cloud Alibaba 三者之间有严格的版本匹配关系，一旦用错了版本，就会产生各种莫名其妙的兼容性问题。

SpringBoot 和 SpringCloud 的版本匹配关系可以从 [Spring 社区网站](https://start.spring.io/actuator/info)获取，Spring Cloud Alibaba 、Spring Boot 和 Spring Cloud 的匹配关系可以从  Spring Cloud Alibaba 的官方[GitHub wiki 页](https://github.com/alibaba/spring-cloud-alibaba/wiki/版本说明)中获取。

接下来，将 Spring Cloud  Alibaba 和 Spring Cloud 的依赖项版本添加到顶层项目的 pom.xml 文件中。

```xml
 <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>2021.0.4</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>2021.0.4.0</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

        </dependencies>   
</dependencyManagement>        
```

定了组件的大版本之后，就可以直接把 Nacos 的依赖项加入到服务中了。由于已经将 Spring Cloud Alibaba 的依赖项版本加到了顶层项目。因此，在添加 Nacos 依赖项到子模块的时候不需要指定`<version>` 内容，当前子模块会尝试从父级项目读取正确的版本信息。

```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```

### Nacos 自动装配原理



