---
title: 本地事务
description: 本地事务是指仅操作单一事务资源的，不需要“全局事务管理器”进行协调的事务。
---

## 概述

本地事务是最基础的一种事务处理方案，通常只适用于单个服务使用单个数据源的场景，它是直接依赖于数据源（通常是数据库系统）本身的事务能力来工作的。在代码层面，我们最多对事务接口做一层标准化的包装（如
JDBC 接口），并不能深入参与到事务的运作过程中。

事务的开启、终止、提交、回滚、嵌套、设置隔离级别、乃至与应用代码贴近的传播方式，全部都要依赖底层数据库的支持。假设代码调用了
JDBC 中的 Transaction::rollback() 方法，方法的成功执行并不代表事务就已经被成功回滚，如果数据表采用的引擎是 MyISAM ，那么
rollback() 方法便是一项没有意义的空操作。

## 实现原子性和持久性

原子性和持久性在事务里是密切相关的两个属性，原子性保证了事务的多个操作要么都生效要么都不生效，不会存在中间状态；持久性保证了一旦事务生效，就不会再因为任何原因而导致其修改的内容被撤销或丢失。

显而易见，数据必须要成功写入磁盘等持久化存储器后才能拥有持久性，只存储在内存中的数据，一旦遇到程序崩溃、数据库崩溃、操作系统崩溃，机器突然宕机等情况就会丢失。

**实现原子性和持久性所面临的困难是,"写入磁盘" 这个操作不是原子的。**存在“写入”、“未写入”和“正在写“的中将状态。

假设存在以下业务场景，从商城购买商品需要修改三个数据：在用户账户中减去商品金额、在商家账户中增加商品金额、在商品仓库中标记商品为配送状态，由于写入存在中间状态，所有会有以下情形：

* **未提交事务**
  ：程序还没修改完三个数据，数据库已经将其中一个或两个数据的变动写入了磁盘，此时出现崩溃，一旦重启之后，数据库必须要有办法得知崩溃前发生过一次不完整的购物操作，将已经修改过的数据从磁盘中恢复成没有修改过的样子，以保证原子性。
* **已提交事务**
  ：程序已经修改完了三个数据，数据库还未将全部三个数据的变动都写入到磁盘，此时出现崩溃，一旦重启之后，数据库必须要有办法得知崩溃前发生过一次完整的购物操作，将还没来得及写入磁盘的那部分数据重新写入，以保证持久性。

这种数据恢复操作被称为**崩溃恢复，也有称作 Failure Recovery 或 Transaction Recovery**
。为了顺利崩溃恢复，在磁盘中写入数据就不能像程序修改内存中变量那样，直接改变某表某列的某个值，必须将修改数据这个操作所需的全部信息（比如修改什么数据、数据物理上位于那个内存页和磁盘块中、从什么值改成什么值等等），以日志的形式（日志特指仅进行顺序追加的文件写入方式，这是最高效的写入方式）先记录到磁盘中。

只有日志记录全部都安全落盘，见到代表事务成功提交的”Commit Record“后，数据库才会根据日志上的信息对真正的数据进行修改，修改完成后，在日志中增加一条”End
Record”表示事务已完成持久化，这种事务实现方式就被称为“Commit Logging”

Commit Logging 保障数据持久性、原子性的原理不难理解：

* 情形一： 日志一旦成功写入 Commit Record ,就代表整个事务是成功的。即使修改数据时崩溃了，重启后根据已经写入磁盘的日志信息恢复现场、继续修改数据即可，这保证了持久性。
* 情形二： 如果日志没有成功写入就发生崩溃，系统重启后会看到一部分没有 Commit Record de
  日志，那将这部分日志标记为回滚状态即可，整个事务就像完全没发生过一样，这保证了原子性。

:::tip
将事务操作保存到一个日志文件后，这个文件中的操作只有全部执行和不执行两种选项，保证了原子性。
:::

## 实现隔离性

隔离性保证了每个事务各自读、写的数据相互独立，不会彼此影响。

隔离性和并发密切相关。 如果没有并发， 所有事务都是串行的，那就不需要任何的隔离。

但现实环境中不可能没有并发，要在并发下实现串行的数据访问，那就必须通过加锁同步的方式，现代数据库提供了以下三种锁：

* 写锁（Write Lock，也叫做排他锁）：只有持有写锁的事务才能对数据进行写入操作，数据施加着写锁时，其它事务不能写入数据，也不能施加读锁。
* 读锁（Read
  Lock，也叫做共享锁）：多个事务可以对同一个数据添加多个读锁，数据被加上读锁后就不会再被加上写锁，所以其他事务不能对该数据进行写入，但仍然可以读取。对于持有读锁的事务，如果该数据只有一个事务加了读锁，那可以直接将其升级为写锁，然后写入数据。
* 范围锁（Range Lock）:对某个范围直接加排他锁，在这个范围内的数据不能被读取，也不能写入：
  ```sql
  SELECT * FROM books WHERE price < 100 FOR UPDATE;
  ```
  范围锁并不是一组排他锁的集合，加了范围锁后，不仅无法修改该范围内已有的数据，也不能在该范围内新增或删除任何数据，这是一组排他锁的集合无法做到的。

### 本地事务的四种隔离级别

#### 可串行化-Serializable

串行化访问提供了强度最高的隔离性，如果不考虑性能的话，对事务所有读、写的数据全部读加上读锁、写锁和范围锁即可实现可串行化。

但数据库不考虑性能肯定是不行的，并发控制理论（Concurrent Control）决定了隔离级别与并发能力是相互抵触的，隔离程度越高，并发访问时的吞吐量就越低。

#### 可重复读-Repeatable Read

可串行化的下一个隔离级别时可重复读。